# GC는 프로그래밍 언어나 런타임 환경에서 자동으로 메모리 관리를 수행하는 기능입니다. 
# GC는 프로그램이 동적으로 할당한 메모리 중에서 더 이상 사용되지 않는 객체들을 식별하고, 
# 해당 객체들이 차지하고 있는 메모리를 해제하여 재사용 가능하게 만듭니다.

# GC의 필요성
# 메모리 누수 방지: 수동으로 메모리를 할당하고 해제하는 작업에서 실수로 메모리를 해제하지 않는 경우가 발생할 수 있습니다.
# 이로 인해 사용되지 않는 메모리가 계속해서 쌓이면서 메모리 누수가 발생할 수 있습니다.
# GC는 이러한 메모리 누수를 방지하여 더 이상 필요하지 않은 메모리를 자동으로 해제합니다.
# 편의성과 생산성: GC를 사용하면 개발자는 명시적으로 메모리 할당과 해제를 관리할 필요가 없습니다.
# 개발자는 객체를 생성하고 사용한 후에 해당 객체에 대한 참조를 제거하기만 하면 됩니다.
# 이로써 개발자는 메모리 관리에 대한 부담을 줄이고, 코드 작성과 유지보수에 더 집중할 수 있습니다.
# 메모리 관리 최적화: GC는 메모리 할당 및 해제를 최적화하여 프로그램의 실행 시간을 향상시킬 수 있습니다.
# GC는 메모리 블록을 재사용하고 메모리 조각화를 방지함으로써 메모리 사용을 최적화합니다.

# GC의 동작 메커니즘
# Root 객체 식별: GC는 시작점으로 사용되는 root 객체들을 식별합니다.
# Root 객체는 프로그램의 시작 지점이며, 주로 전역 변수, 스택의 변수 등이 될 수 있습니다.
# Root 객체들은 도달 가능한 객체들의 집합의 출발점으로 동작합니다.
# 도달 가능한 객체 식별 (Marking): GC는 root 객체들부터 출발하여 도달 가능한 객체들을 식별합니다.
# 이 단계에서는 프로그램의 실행 흐름에 따라 객체 간의 참조를 따라가며 도달 가능한 객체를 표시합니다.
# 일반적으로 표시 비트나 플래그를 사용하여 객체에 표시합니다.
# 도달 가능하지 않은 객체 식별 (Sweeping): Marking 단계에서 표시되지 않은 객체들은 도달 불가능한 객체로 간주됩니다.
# GC는 이러한 도달 불가능한 객체들을 식별하고 메모리를 해제하여 재사용 가능한 상태로 만듭니다.
# 이 단계에서는 사용되지 않는 객체들의 메모리를 해제하는 작업이 이루어집니다.
# 압축 (Optional): 일부 GC 알고리즘은 Compact 단계를 추가로 수행할 수 있습니다.
# 이 단계에서는 메모리 조각화를 최소화하기 위해 객체들을 한 곳으로 모으고, 가용 메모리 영역을 확보합니다.

# GC가 제대로 동작하도록 코드를 작성하는 방법
# 1. 불필요한 객체 참조 제거: GC는 도달 가능한 객체를 식별하여 메모리를 관리합니다.
# 따라서, GC가 제대로 동작하려면 불필요한 객체에 대한 참조를 명시적으로 제거해야 합니다.
# 예를 들어, 함수 내에서 생성한 객체가 함수 실행이 끝난 후에도 참조되는 경우, GC는 해당 객체를 도달 가능한 객체로 판단하여 메모리를 해제하지 않습니다.
# 따라서, 함수 실행 후에는 해당 객체에 대한 참조를 명시적으로 제거해야 합니다.

# 2. 순환 참조 주의:
# GC는 순환 참조된 객체들을 제대로 처리해야 메모리 누수를 방지할 수 있습니다. 순환 참조는 두 개 이상의 객체들이 서로를 참조하는 상황을 의미합니다.
# 이런 경우, GC는 도달 가능한 객체로 판단하고 해당 객체들의 메모리를 해제하지 않습니다.

# 1. 예제 코드

class SomeObject:
    def __init__(self):
        pass

def create_objects():
    obj = SomeObject()  # SomeObject 인스턴스 생성
    # obj 사용

create_objects()

# 위의 예제에서 create_objects() 함수 실행이 끝나면 obj 변수에 대한 참조가 사라지지 않습니다.
# 이는 GC가 해당 객체를 도달 가능한 객체로 인식하여 메모리 해제를 지연시킬 수 있습니다.
# 제대로 동작하는 코드로 수정하려면 다음과 같이 obj에 대한 참조를 제거해야 합니다.

def create_objects():
    obj = SomeObject()  # SomeObject 인스턴스 생성
    # obj 사용
    del obj  # obj 참조 제거

create_objects()


# 2. 예제 코드

class Node:
    def __init__(self):
        self.next = None

# 순환 참조 생성
node1 = Node()
node2 = Node()
# node1.next = node2
# node2.next = node1
# 위의 예제에서 node1과 node2가 서로를 참조하고 있기 때문에 GC는 이들을 도달 가능한 객체로 인식하고 메모리를 해제하지 않습니다. 
# 이를 방지하기 위해 순환 참조를 끊어주어야 합니다.

node1.next = None
node2.next = None # 순환 참조 해제
# 위와 같이 순환 참조를 끊어주면 GC가 해당 객체들을 도달 불가능한 객체로 인식하여 메모리를 해제할 수 있습니다.

# 메모리 leak이 발생되는 예제 코드

def create_leak():
    global_list = []

    def append_to_list():
        global_list.append("data")

    while True:
        append_to_list()

# 위의 코드에서 create_leak() 함수는 무한 루프를 실행하면서 global_list에 계속해서 "data"를 추가합니다.
#  이 때, global_list는 함수 내에서 생성되었지만 함수가 루프를 돌면서 계속 참조되기 때문에 함수 실행이 종료되더라도 메모리에서 해제되지 않습니다.
# 이 코드에서 GC가 동작해도 global_list는 도달 가능한 객체로 인식되기 때문에 메모리 누수가 발생합니다.
#  GC는 도달 가능한 객체만을 해제할 수 있기 때문에, 함수가 무한 루프를 실행하는 동안 global_list는 계속 참조되므로 메모리가 해제되지 않습니다.

# 3